[{"name":"Http.XSRF","comment":" This package helps you make [XSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) protected HTTP requests.\n\nThis package was designed to be used with [servant-auth](https://hackage.haskell.org/package/servant-auth). However it should be compatible with any\nbackend that supports cookie based XSRF authentication.\n\nYou can find a complete example of an elm app and a servant-auth backend using XSRF tokens [here](https://github.com/3kyro/servant-auth-elm.git).\n\n\n# Setup\n\nIn order to get the cookies that the server has set, you need to ask javascript for it. The simplest way is to get hold\noff all cookies with the `document.cookie` property.\n\nYou can use a flag for passing cookies at page initialization:\n\n    // you would normally put this in a <script> tag inside your app's\n    // index.html file\n    let app = Elm.App.init(\n        { node: document.getElementById(\"myapp\")\n        // Pass all cookies to elm at initialization.\n        // Useful even if you are listening to cookie changes as you'll have the right\n        // value in elm even if the page reloads.\n        , flags: document.cookie\n        }\n    );\n\nThis however will not work when the server sets the xsrf cookie after the page has loaded, when responding to\na login request for example. Unfortunately as of now (December 2020) there is no standard way to listen on cookie changes.\nYou'll have to make the listener yourself:\n\n    // Inside the same <script> tag as the previous app declaration\n    // An onChange listener for cookies\n    function onCookieChange(callback, interval = 1000) {\n        let prevCookie = document.cookie;\n        setInterval(()=> {\n            let cookie = document.cookie;\n            if (cookie !== prevCookie) {\n                callback(cookie);\n            }\n        }, interval);\n    }\n\nYou can send the changed cookies to Elm using a port\n\n        // Still inside the <script> tag, after the declaration of app\n        // Send changed cookies to elm\n        onCookieChange( cookie => app.ports.toElm.send(cookie));\n\nThe finished javascript part would look like this:\n\n    <script>\n        // An onChange listener for cookies\n        function onCookieChange(callback, interval = 1000) {\n            let prevCookie = document.cookie;\n            setInterval(()=> {\n                let cookie = document.cookie;\n                if (cookie !== prevCookie) {\n                    callback(cookie);\n                }\n            }, interval);\n        }\n\n        let app = Elm.App.init(\n            { node: document.getElementById(\"myapp\")\n            // Pass all cookies to elm at initialization.\n            // Useful even if you are listening to cookie changes as you'll have the right\n            // value in elm even in page reloads.\n            , flags: document.cookie\n            }\n        );\n\n        // Send changed cookies to elm\n        onCookieChange( cookie => app.ports.toElm.send(cookie));\n    </script>\n\nIn Elm land, you'll need to retrieve the cookies sent by javascript. You should handle flags and\nports as per elm's [documentation](https://guide.elm-lang.org/interop/).\n\n    -- main parametrised to String to recieve the initial cookies\n    main : Program String Model Msg\n    main =\n        Browser.element\n            { init = init\n            , view = view\n            , update = update\n            , subscriptions = subscriptions\n            }\n\n    -- Initialize the elm runtime with the cookies loaded\n    init : String -> ( Model, Cmd Msg )\n    init cookies =\n        -- initModel sets a value of Model containing the cookies String\n        ( initModel cookies\n        , initCmd\n        )\n\n    -- Listen for the cookies listener message\n    port toElm : (String -> msg) -> Sub msg\n\n    -- Subscribe to cookie changes\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        -- fire up CookieUpdate when you receive a mesage from javascript\n        toElm CookieUpdate\n\n    -- Update the model cookies value\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            -- There will be other\n            -- (most probably a lot of them)\n            -- messages here\n            CookieUpdate str ->\n                ( { model | cookies = str }\n                , Cmd.none\n                )\n\n\n# Requests\n\nNow that you have all current cookies in your elm app, you should check if one of them is a valid XSRF one.\n\n@docs token\n\nHaving a valid token, you can now make some requests\n\n@docs authGet\n@docs authPost\n@docs authRequest\n\n","unions":[],"aliases":[],"values":[{"name":"authGet","comment":" Similar to [Http.get](https://package.elm-lang.org/packages/elm/http/latest/Http#get), but\nyou need to also provide a XSRF header name and token.\n\n    -- A protected request for an email address\n    getEmailRequest : Model -> Cmd Msg\n    getEmailRequest model =\n        XSRF.authGet\n            { url = \"http://localhost:4000/email\"\n            , expect = Http.expectJson ReceivedEmail D.string\n            , xsrfHeaderName = \"X-XSRF-TOKEN\"\n            , xsrfToken = XSRF.token \"XSRF-TOKEN=\" model.cookies\n            }\n\n","type":"{ url : String.String, expect : Http.Expect msg, xsrfHeaderName : String.String, xsrfToken : Maybe.Maybe String.String } -> Platform.Cmd.Cmd msg"},{"name":"authPost","comment":" Similar to [Http.post](https://package.elm-lang.org/packages/elm/http/latest/Http#post), but\nyou need to also provide a XSRF header name and token.\n","type":"{ url : String.String, body : Http.Body, expect : Http.Expect msg, xsrfHeaderName : String.String, xsrfToken : Maybe.Maybe String.String } -> Platform.Cmd.Cmd msg"},{"name":"authRequest","comment":" Similar to [Http.request](https://package.elm-lang.org/packages/elm/http/latest/Http#request), but\nyou need to also provide a XSRF header name and token.\n\nIn case you don't want to provide any other header except the XSRF one, you can apply the empty list\nin the headers argument\n\n    -- saves a blog post\n    putPost : String -> String -> Cmd msg\n    putPost cookies post =\n        XSRF.autRequest\n            { method = \"PUT\"\n            , headers = []\n            , url = \"http://localhost:4000/savePost\"\n            , body = Http.jsonBody <| E.string post\n            , expect = Http.expectWhatever\n            , xsrfHeaderName = \"XSRF-CUSTOM\"\n            , xserfToken = XSRF.token \"XSRF-COOKIE=\" cookies\n            , timeout = Nothing\n            , tracker = Nothing\n            }\n\n","type":"{ method : String.String, headers : List.List Http.Header, url : String.String, body : Http.Body, expect : Http.Expect msg, xsrfHeaderName : String.String, xsrfToken : Maybe.Maybe String.String, timeout : Maybe.Maybe Basics.Float, tracker : Maybe.Maybe String.String } -> Platform.Cmd.Cmd msg"},{"name":"token","comment":" Get an XSRF token from a string containing various cookies.\nThe first argument is name the server used to set the XSRF cookie\ne.g. \"XSRF-TOKEN=\"\n\n    token \"XSRF-TOKEN=\" model.cookies\n\n","type":"String.String -> String.String -> Maybe.Maybe String.String"}],"binops":[]}]